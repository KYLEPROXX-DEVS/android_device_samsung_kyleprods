diff -ur a/build/core/tasks/kernel.mk b/build/core/tasks/kernel.mk
--- a/build/core/tasks/kernel.mk	2017-01-05 20:54:28.132535346 +1100
+++ b/build/core/tasks/kernel.mk	2017-01-02 01:43:12.303779000 +1100
@@ -175,7 +175,11 @@
     ccache := $(strip $(wildcard $(ccache)))
 endif
 
-KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(KERNEL_TOOLCHAIN_PATH)"
+ifneq ($(TARGET_KERNEL_CUSTOM_TOOLCHAIN),)     
+    KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(ANDROID_BUILD_TOP)/prebuilts/gcc/linux-x86/arm/$(TARGET_KERNEL_CUSTOM_TOOLCHAIN)/bin/arm-eabi-"      
+else
+    KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(KERNEL_TOOLCHAIN_PATH)"
+endif
 ccache =
 
 define mv-modules
diff -ur a/external/icu/icu4c/source/common/ucnv.c b/external/icu/icu4c/source/common/ucnv.c
--- a/external/icu/icu4c/source/common/ucnv.c	2017-01-05 20:56:29.141835912 +1100
+++ b/external/icu/icu4c/source/common/ucnv.c	2017-01-02 01:47:30.381882000 +1100
@@ -2914,6 +2914,76 @@
             return FALSE;
     }
 }
+
+U_CAPI void    U_EXPORT2 ucnv_setToUCallBack_48 (UConverter * converter,
+                            UConverterToUCallback newAction,
+                            const void* newContext,
+                            UConverterToUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+  ucnv_setToUCallBack(converter, newAction, newContext,
+        oldAction, oldContext, err);
+}
+
+U_CAPI void  U_EXPORT2 ucnv_close_48 (UConverter * converter) {
+  ucnv_close (converter);
+}
+
+U_CAPI void  U_EXPORT2
+ucnv_setFromUCallBack_48 (UConverter * converter,
+                            UConverterFromUCallback newAction,
+                            const void* newContext,
+                            UConverterFromUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+
+  ucnv_setFromUCallBack(converter, newAction, newContext, oldAction,
+        oldContext, err);
+}
+
+U_CAPI void U_EXPORT2
+ucnv_convertEx_48 (UConverter *targetCnv, UConverter *sourceCnv,
+               char **target, const char *targetLimit,
+               const char **source, const char *sourceLimit,
+               UChar *pivotStart, UChar **pivotSource,
+               UChar **pivotTarget, const UChar *pivotLimit,
+               UBool reset, UBool flush,
+               UErrorCode *pErrorCode) {
+  ucnv_convertEx(targetCnv, sourceCnv, target, targetLimit, source,
+        sourceLimit, pivotStart, pivotSource,
+        pivotTarget, pivotLimit, reset, flush,
+        pErrorCode);
+}
+
+U_CAPI UConverter* U_EXPORT2
+ucnv_open_48 (const char *name,
+                       UErrorCode * err) {
+  return ucnv_open(name, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_FROM_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterFromUnicodeArgs *fromUArgs,
+                  const UChar* codeUnits,
+                  int32_t length,
+                  UChar32 codePoint,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_FROM_U_CALLBACK_STOP(context, fromUArgs, codeUnits,
+      length, codePoint, reason, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_TO_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterToUnicodeArgs *toUArgs,
+                  const char* codeUnits,
+                  int32_t length,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_TO_U_CALLBACK_STOP(context, toUArgs, codeUnits, length,
+      reason, err);
+}
+
 #endif
 
 /*
diff -ur a/external/sepolicy/domain.te b/external/sepolicy/domain.te
--- a/external/sepolicy/domain.te	2017-01-05 20:57:38.308242423 +1100
+++ b/external/sepolicy/domain.te	2017-01-02 01:50:19.433543000 +1100
@@ -239,7 +239,7 @@
 # init starts in kernel domain and switches to init domain via setcon in
 # the init.rc, so the setenforce occurs while still in kernel. After
 # switching domains, there is never any need to setenforce again by init.
-neverallow domain kernel:security setenforce;
+# neverallow domain kernel:security setenforce;
 neverallow { domain -kernel } kernel:security setcheckreqprot;
 
 # No booleans in AOSP policy, so no need to ever set them.
@@ -324,11 +324,7 @@
 # Restrict context mounts to specific types marked with
 # the contextmount_type attribute.
 # Omni addition
-ifelse(shipping_build, `true',
-  `neverallow domain {fs_type -contextmount_type}:filesystem relabelto;'
-,
-  `neverallow domain {fs_type -contextmount_type -sdcard_posix}:filesystem relabelto;'
-)
+neverallow domain {fs_type -contextmount_type -sdcard_posix}:filesystem relabelto;
 
 # Ensure that context mount types are not writable, to ensure that
 # the write to /system restriction above is not bypassed via context=
diff -ur a/external/tinyalsa/include/tinyalsa/asoundlib.h b/external/tinyalsa/include/tinyalsa/asoundlib.h
--- a/external/tinyalsa/include/tinyalsa/asoundlib.h	2017-01-05 20:57:53.240440847 +1100
+++ b/external/tinyalsa/include/tinyalsa/asoundlib.h	2017-01-02 02:24:10.081511000 +1100
@@ -241,6 +241,7 @@
 int pcm_prepare(struct pcm *pcm);
 /* Start and stop a PCM channel that doesn't transfer data */
 int pcm_start(struct pcm *pcm);
+int pcm_drain(struct pcm *pcm);
 int pcm_stop(struct pcm *pcm);
 
 /* ioctl function for PCM driver */
diff -ur a/external/tinyalsa/pcm.c b/external/tinyalsa/pcm.c
--- a/external/tinyalsa/pcm.c	2017-01-05 20:57:53.240440847 +1100
+++ b/external/tinyalsa/pcm.c	2017-01-02 02:23:31.218438000 +1100
@@ -1027,6 +1027,14 @@
     return 0;
 }
 
+int pcm_drain(struct pcm *pcm)
+{
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DRAIN) < 0)
+        return oops(pcm, errno, "drain failed");
+
+    return 0;
+}
+
 int pcm_stop(struct pcm *pcm)
 {
     if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DROP) < 0)
diff -ur a/frameworks/base/telephony/java/android/telephony/TelephonyManager.java b/frameworks/base/telephony/java/android/telephony/TelephonyManager.java
--- a/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2017-01-05 20:58:59.923452139 +1100
+++ b/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2017-01-02 01:56:58.592271000 +1100
@@ -3247,49 +3247,20 @@
      * @hide
      */
     public static void setTelephonyProperty(int phoneId, String property, String value) {
-        String propVal = "";
-        String p[] = null;
-        String prop = SystemProperties.get(property);
-
-        if (value == null) {
-            value = "";
-        }
-
-        if (prop != null) {
-            p = prop.split(",");
-        }
 
         if (!SubscriptionManager.isValidPhoneId(phoneId)) {
             Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId +
-                    " property=" + property + " value: " + value + " prop=" + prop);
+                    " property=" + property + " value: " + value);
             return;
         }
 
-        for (int i = 0; i < phoneId; i++) {
-            String str = "";
-            if ((p != null) && (i < p.length)) {
-                str = p[i];
-            }
-            propVal = propVal + str + ",";
-        }
-
-        propVal = propVal + value;
-        if (p != null) {
-            for (int i = phoneId + 1; i < p.length; i++) {
-                propVal = propVal + "," + p[i];
-            }
-        }
-
-        if (property.length() > SystemProperties.PROP_NAME_MAX
-                || propVal.length() > SystemProperties.PROP_VALUE_MAX) {
-            Rlog.d(TAG, "setTelephonyProperty: property to long phoneId=" + phoneId +
-                    " property=" + property + " value: " + value + " propVal=" + propVal);
-            return;
+        if (phoneId > 0) {
+            property += "_" + phoneId;
         }
 
         Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId +
-                " property=" + property + " value: " + value + " propVal=" + propVal);
-        SystemProperties.set(property, propVal);
+                " property=" + property + " value: " + value);
+        SystemProperties.set(property, value);
     }
 
     /**
@@ -3386,15 +3357,22 @@
      * @hide
      */
     public static String getTelephonyProperty(int phoneId, String property, String defaultVal) {
-        String propVal = null;
-        String prop = SystemProperties.get(property);
-        if ((prop != null) && (prop.length() > 0)) {
-            String values[] = prop.split(",");
-            if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
-                propVal = values[phoneId];
-            }
+        if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+            Rlog.d(TAG, "getTelephonyProperty: invalid phoneId=" + phoneId +
+                    " property=" + property);
+            return defaultVal;
         }
-        return propVal == null ? defaultVal : propVal;
+
+        if (phoneId > 0) {
+            property += "_" + phoneId;
+        }
+
+        String propVal = SystemProperties.get(property);
+
+        Rlog.d(TAG, "getTelephonyProperty: return propVal='" + propVal + "' phoneId=" + phoneId
+                + " property='" + property + "' defaultVal='" + defaultVal);
+
+        return propVal.isEmpty() ? defaultVal : propVal;
     }
 
     /** @hide */
Binary files a/frameworks/native/.git/index and b/frameworks/native/.git/index differ
diff -ur a/frameworks/native/libs/binder/Parcel.cpp b/frameworks/native/libs/binder/Parcel.cpp
--- a/frameworks/native/libs/binder/Parcel.cpp	2017-01-05 20:59:10.168840408 +1100
+++ b/frameworks/native/libs/binder/Parcel.cpp	2017-01-02 01:58:38.209822000 +1100
@@ -896,6 +896,12 @@
     return writeString16(str.string(), str.size());
 }
 
+extern "C" status_t _ZN7android6Parcel13writeString16EPKDsj(void *parcel, const char16_t* str, size_t len);
+
+extern "C" status_t _ZN7android6Parcel13writeString16EPKtj(void *parcel, const char16_t* str, size_t len) {
+    return _ZN7android6Parcel13writeString16EPKDsj(parcel, str, len);
+}
+
 status_t Parcel::writeString16(const char16_t* str, size_t len)
 {
     if (str == NULL) return writeInt32(-1);
diff -ur a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2017-01-05 20:59:10.308804726 +1100
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2017-01-02 01:59:47.793775000 +1100
@@ -3361,6 +3361,10 @@
         bool useReadPixels)
 {
     ATRACE_CALL();
+// Rotation artifact problems when useReadPixels is false
+#ifdef HAWAII_HWC
+    useReadPixels = true;
+#endif
 
     // get screen geometry
     uint32_t hw_w = hw->getWidth();
diff -ur a/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2017-01-05 20:59:14.911631263 +1100
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2017-01-02 02:04:35.516031000 +1100
@@ -224,6 +224,7 @@
     boolean mDnsCheckDisabled;
     public DcTrackerBase mDcTracker;
     boolean mDoesRilSendMultipleCallRing;
+    boolean mDoesRilSendCallRing;
     int mCallRingContinueToken;
     int mCallRingDelay;
     public boolean mIsTheCurrentActivePhone = true;
@@ -457,6 +458,11 @@
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
 
+        // Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
+
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
         Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);
@@ -2065,6 +2071,18 @@
     public void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+
+        // Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -2641,6 +2659,7 @@
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+        pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
diff -ur a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java	2017-01-05 20:59:14.915630243 +1100
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java	2017-01-02 02:05:24.842046000 +1100
@@ -300,7 +300,7 @@
     static final int RESPONSE_SOLICITED = 0;
     static final int RESPONSE_UNSOLICITED = 1;
 
-    static final String[] SOCKET_NAME_RIL = {"rild", "rild2", "rild3"};
+    static final String[] SOCKET_NAME_RIL = {"rild", "rild1", "rild2"};
 
     static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
 
diff -ur a/hardware/broadcom/libbt/src/userial_vendor.c b/hardware/broadcom/libbt/src/userial_vendor.c
--- a/hardware/broadcom/libbt/src/userial_vendor.c	2017-01-05 20:59:19.326505648 +1100
+++ b/hardware/broadcom/libbt/src/userial_vendor.c	2017-01-02 02:07:53.844526000 +1100
@@ -196,6 +196,10 @@
     uint16_t parity;
     uint8_t stop_bits;
 
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    int ldisc;
+#endif
+
     vnd_userial.fd = -1;
 
     if (!userial_to_tcio_baud(p_cfg->baud, &baud))
@@ -265,6 +269,13 @@
     tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
 
 #if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    // TODO: check for breakage on tuna (Galaxy Nexus). It defines this,
+    //       but does not contain the kernel code to support it.
+
+    // Switch to N_BRCM_HCI line disclipline for ioctl to work
+    ldisc = 25; // N_BRCM_HCI
+    ioctl(vnd_userial.fd, TIOCSETD, &ldisc);
+
     userial_ioctl_init_bt_wake(vnd_userial.fd);
 #endif
 
diff -ur a/packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/utils/JniUtils.java b/packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/utils/JniUtils.java
--- a/packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/utils/JniUtils.java	2017-01-05 21:00:33.443599888 +1100
+++ b/packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/utils/JniUtils.java	2017-01-02 02:09:53.472517000 +1100
@@ -26,14 +26,10 @@
     public static boolean mHaveGestureLib = false;
     static {
         try {
-            System.loadLibrary(JniLibName.JNI_LIB_NAME2);
+            System.loadLibrary(JniLibName.JNI_LIB_NAME);
             mHaveGestureLib = true;
-        } catch (UnsatisfiedLinkError ue) {
-            try {
-                System.loadLibrary(JniLibName.JNI_LIB_NAME);
-            } catch (UnsatisfiedLinkError ule) {
-                Log.e(TAG, "Could not load native library " + JniLibName.JNI_LIB_NAME, ule);
-            }
+        } catch (UnsatisfiedLinkError ule) {
+            Log.e(TAG, "Could not load native library " + JniLibName.JNI_LIB_NAME, ule);
         }
     }
 
diff -ur a/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java b/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java
--- a/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java	2017-01-05 21:00:32.975719283 +1100
+++ b/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java	2017-01-02 02:10:56.590523000 +1100
@@ -22,5 +22,4 @@
     }
 
     public static final String JNI_LIB_NAME = "jni_latinime";
-    public static final String JNI_LIB_NAME2 = "jni_latinimegoogle";
 }
diff -ur a/system/core/init/init.cpp b/system/core/init/init.cpp
--- a/system/core/init/init.cpp	2017-01-05 21:04:48.586432148 +1100
+++ b/system/core/init/init.cpp	2017-01-02 02:16:05.893645000 +1100
@@ -69,6 +69,8 @@
 
 static int property_triggers_enabled = 0;
 
+static char hardware[32];
+static unsigned revision = 0;
 static char qemu[32];
 
 static struct action *cur_action = NULL;
@@ -798,6 +800,9 @@
 }
 
 static void export_kernel_boot_props() {
+    char tmp[PROP_VALUE_MAX];
+    int ret;
+
     struct {
         const char *src_prop;
         const char *dst_prop;
@@ -807,14 +812,25 @@
         { "ro.boot.mode",       "ro.bootmode",   "unknown", },
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
-        { "ro.boot.hardware",   "ro.hardware",   "unknown", },
-        { "ro.boot.revision",   "ro.revision",   "0", },
     };
     for (size_t i = 0; i < ARRAY_SIZE(prop_map); i++) {
         char value[PROP_VALUE_MAX];
         int rc = property_get(prop_map[i].src_prop, value);
         property_set(prop_map[i].dst_prop, (rc > 0) ? value : prop_map[i].default_value);
     }
+   get_hardware_name(hardware, &revision);
+
+   /* if this was given on kernel command line, override what we read
+    * before (e.g. from /proc/cpuinfo), if anything */
+   ret = property_get("ro.boot.hardware", tmp);
+   if (ret)
+       strlcpy(hardware, tmp, sizeof(hardware));
+   property_set("ro.hardware", hardware);
+
+   ret = property_get("ro.boot.revision", tmp);
+   if (!ret)
+       snprintf(tmp, PROP_VALUE_MAX, "%d", revision);
+   property_set("ro.revision", tmp);
 }
 
 static void process_kernel_dt(void)
diff -ur a/system/core/init/util.cpp b/system/core/init/util.cpp
--- a/system/core/init/util.cpp	2017-01-05 21:04:48.586432148 +1100
+++ b/system/core/init/util.cpp	2017-01-02 02:16:56.728293000 +1100
@@ -401,6 +401,34 @@
     }
 }
 
+void get_hardware_name(char *hardware, unsigned int *revision) {
+  FILE* fp = fopen("/proc/cpuinfo", "re");
+  if (fp == NULL) {
+    return;
+  }
+  char buf[1024];
+  while (fgets(buf, sizeof(buf), fp) != NULL) {
+    if (strncmp(buf, "Hardware", 8) == 0) {
+      const char* hw = strstr(buf, ": ");
+      if (hw) {
+        hw += 2;
+        size_t n = 0;
+        while (*hw) {
+          if (!isspace(*hw)) {
+            hardware[n++] = tolower(*hw);
+          }
+          hw++;
+          if (n == 31) break;
+        }
+        hardware[n] = 0;
+      }
+    } else if (strncmp(buf, "Revision", 8) == 0) {
+      sscanf(buf, "Revision : %ux", revision);
+    }
+  }
+  fclose(fp);
+}
+
 void import_kernel_cmdline(bool in_qemu, std::function<void(char*,bool)> import_kernel_nv)
 {
     char cmdline[2048];
diff -ur a/system/core/init/util.h b/system/core/init/util.h
--- a/system/core/init/util.h	2017-01-05 21:04:48.586432148 +1100
+++ b/system/core/init/util.h	2017-01-02 02:17:44.299049000 +1100
@@ -58,6 +58,7 @@
 void remove_link(const char *oldpath, const char *newpath);
 int wait_for_file(const char *filename, int timeout);
 void open_devnull_stdio(void);
+void get_hardware_name(char *hardware, unsigned int *revision);
 void import_kernel_cmdline(bool in_qemu, std::function<void(char*,bool)>);
 int make_dir(const char *path, mode_t mode);
 int restorecon(const char *pathname);
diff -ur a/system/core/libnetutils/ifc_utils.c b/system/core/libnetutils/ifc_utils.c
--- a/system/core/libnetutils/ifc_utils.c	2017-01-05 21:04:48.602428059 +1100
+++ b/system/core/libnetutils/ifc_utils.c	2017-01-02 02:18:56.965183000 +1100
@@ -701,3 +701,19 @@
 
     return 0;
 }
+
+// Required for Broadcom RILD
+int ifc_set_mtu(const char *name, int mtuSz)
+{
+    struct ifreq ifr;
+    int ret;
+    ifc_init_ifr(name, &ifr);
+    ifr.ifr_mtu = mtuSz;
+
+    ret = ioctl(ifc_ctl_sock, SIOCSIFMTU, &ifr);
+    if (ret < 0) {
+        printerr("ifc_set_mtu: SIOCSIFMTU failed: %d\n", ret);
+    }
+
+    return ret;
+}
